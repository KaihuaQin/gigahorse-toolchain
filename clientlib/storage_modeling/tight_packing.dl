
#define MERGED_STORAGE_VAR(storVar,byteLow,byteHigh) cat(storVar, cat("_", cat(to_string(byteLow), cat("_", to_string(byteHigh)))))

.decl SLOADOfConst(sload:Statement, const:Value, var:Variable)
.decl SSTOREToConst(sstore:Statement, const:Value, var:Variable)

SLOADOfConst(sload, const, var):-
  SLOAD(sload, constVar, var),
  Variable_Value(constVar, const).

SSTOREToConst(sstore, const, var):-
  SSTORE(sstore, constVar, var),
  Variable_Value(constVar, const).


/**
  __Note__: Contains both top-level global variables and storage constructs as they
  both need the same handling for word sharing in storage slots. They are differentiated later.
*/
.decl VarHoldsBytesOfStorVar(var: Variable, srcLoad: Statement, storVar: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(VarHoldsBytesOfStorVar)
/**
  This is a heuristic, we use the "Final" forms of loaded vars
  (seeing when a variable from storage is no longer shifted or masked)
  to see that the limits of merged variables are modeled correctly
  but then any VarHoldsBytesOfStorVar corresponding to a valid variable
  is considered a LOAD of that variable.

  __Note__: Contains both top-level global variables and storage constructs as they
  both need the same handling for word sharing in storage slots. They are differentiated later.
*/
.decl VarHoldsBytesOfStorVarFinal(var: Variable, srcLoad: Statement, storVar: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(VarHoldsBytesOfStorVarFinal)

VarHoldsBytesOfStorVar(to, load, storVar, 0, 31):-
  SLOADOfConst(load, storVar, to).

// VarHoldsBytesOfStorVar(to, sload, index, 0, 31):-
//   SLOAD(sload, indexVar, to),
//   Variable_StorageIndex(indexVar, index),
//   IsStorageConstruct(["VAR", index]).

VarHoldsBytesOfStorVar(to, load, storVar, low + bytes, high):-
  VarHoldsBytesOfStorVar(shiftedVar, load, storVar, low, high),
  RShiftBytes(shiftedVar, to, bytes).

VarHoldsBytesOfStorVar(to, load, storVar, low, newHigh):-
  VarHoldsBytesOfStorVar(var, load, storVar, low, high),
  newHigh = min(high, low + maskLen - 1),
  LowBytesMaskOp(var, to, maskLen).


VarHoldsBytesOfStorVarFinal(var, load, storVar, low, high):-
  VarHoldsBytesOfStorVar(var, load, storVar, low, high),
  //!LShiftBytes(var, _, _),
  !RShiftBytes(var, _, _),
  !LowBytesMaskOp(var, _, _),
  !AntiMaskOp(var, _, _, _).

.decl AnyLoadStoreStorVarBytes(loadOrStore: Statement, storVar: symbol, low: number, high: number)
DEBUG_OUTPUT(AnyLoadStoreStorVarBytes)

.decl FailedMergedStorageModeling(storVar: symbol)
DEBUG_OUTPUT(FailedMergedStorageModeling)

.decl FailedMergedStorageModelingReason(storVar: symbol, stmt: Statement, stmt2: Statement, range1: Range, range2: Range)
DEBUG_OUTPUT(FailedMergedStorageModelingReason)

.decl SuccessfulMergedStorageModeling(storVar: symbol)
DEBUG_OUTPUT(SuccessfulMergedStorageModeling)

.decl LoadOrStoreToStoreVar(stmt: Statement, storVar: symbol)

AnyLoadStoreStorVarBytes(stmt, storVar, low, high):-
  VarHoldsBytesOfStorVarFinal(_, stmt, storVar, low, high);
  VarWrittenToBytesOfStorVar(_, stmt, storVar, low, high);
  // Will need to handle these differently because in optimized code a single constant can initialize many vars
  ConstWrittenToBytesOfStorVar(_, _, stmt, _, storVar, low, high).

AnyLoadStoreStorVarBytes(stmt, storVar, 0, 31):-
  SSTOREToConst(stmt, storVar, _),
  !SLOADOfConst(_, storVar, _).

FailedMergedStorageModelingReason(storVar, stmt, stmt2, [low, high], [otherLow, otherHigh]),
FailedMergedStorageModeling(storVar):-
  AnyLoadStoreStorVarBytes(stmt, storVar, low, high),
  AnyLoadStoreStorVarBytes(stmt2, storVar, otherLow, otherHigh),  otherLow = otherLow, otherHigh = otherHigh, // NOWARN
  !ArrayIdToStorageIndex(as(storVar, Value), _),
  (low != otherLow ; high != otherHigh),
  ( (low < otherLow , otherLow < high) ; (low < otherHigh, otherHigh < high) ).

LoadOrStoreToStoreVar(stmt, storVar):-
  SLOADOfConst(stmt, storVar, _);
  SSTOREToConst(stmt, storVar, _).

FailedMergedStorageModelingReason(storVar, stmt, stmt, nil, nil),
FailedMergedStorageModeling(storVar):-
  AnyLoadStoreStorVarBytes(_, storVar, _, _),
  LoadOrStoreToStoreVar(stmt, storVar),
  !UselessSLOAD(stmt),
  !AnyLoadStoreStorVarBytes(stmt, storVar, _, _),
  !BytesOfStorVarKept(_, stmt, storVar, _, _),
  !ConstWrittenToBytesOfStorVar(_, _, _, stmt, storVar, _, _),
  !ArrayIdToStorageIndex(as(storVar, Value), _).


SuccessfulMergedStorageModeling(storVar):-
  AnyLoadStoreStorVarBytes(_, storVar, _, _),
  !FailedMergedStorageModeling(storVar),
  !ArrayIdToStorageIndex(as(storVar, Value), _).

/**
  Models complex expressions of many shifted and masked vars to update a single storage slot.
  Bytes `byteLow` to `byteHigh` of `var` hold `writtenVarOrConst` which is of ("CONST" of "VAR") `kind`.
*/
.decl ProbablyPartialStorageUpdateSequenceWrite(var: Variable, kind: symbol, writtenVarOrConst: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(ProbablyPartialStorageUpdateSequenceWrite)

/**
  Models complex expressions of many shifted and masked vars to update a single storage slot.
  Bytes `byteLow` to `byteHigh` of `var` hold the existing bytes stored in the storage slot of `storVar`, as loaded in `load`.
*/
.decl ProbablyPartialStorageUpdateSequenceKeep(var: Variable, load: Statement, storVar: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(ProbablyPartialStorageUpdateSequenceKeep)

/**
  A single addition to a complex expression updating a tightly packed storage slot.
  Complex expression in `toVar` is the one in `fromVar` with the addition of `varOrConst` which is of ("CONST" of "VAR") `kind`
  in bytes `byteLow` to `byteHigh`.
*/
.decl ProbablyPartialStorageUpdatePattern(fromVar: Variable, toVar: Variable, kind: symbol, varOrConst: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(ProbablyPartialStorageUpdatePattern)

.decl VarWrittenToBytesOfStorVar(var: Variable, store: Statement, storVar: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(VarWrittenToBytesOfStorVar)

/**
 Special case of `VarWrittenToBytesOfStorVar` to fix a bug when writting from one storage location to another,
*/
.decl VarWrittenToBytesOfStorVarIsMergedVar(var:Variable, modeledVar:Variable, store:Statement, storVar:symbol, byteLow:number, byteHigh:number)

/**
  Filtered `VarWrittenToBytesOfStorVar`, taking `VarWrittenToBytesOfStorVarIsMergedVar` into account.
*/
.decl VarWrittenToBytesOfStorVarFinal(var:Variable, store:Statement, storVar:symbol, byteLow:number, byteHigh:number)

.decl ConstWrittenToBytesOfStorVar(constVar:Variable, const:Value, store:Statement, load:Statement, storVar:symbol, byteLow:number, byteHigh:number)
DEBUG_OUTPUT(ConstWrittenToBytesOfStorVar)

ProbablyPartialStorageUpdatePattern(fromVar, toVar, "VAR", writtenVar, byteLow, byteLow + castedTo - 1):-
  CastedAndShiftedVar(writtenVar, castedNShifted, byteLow, castedTo),
  (OR(_, castedNShifted, fromVar, toVar) ; OR(_, fromVar, castedNShifted, toVar)).

ProbablyPartialStorageUpdatePattern(fromVar, toVar, "VAR", writtenVar, 0, byteHigh - 1):-
  LowBytesMaskOp(writtenVar, castedVar, byteHigh),
  (OR(_, castedVar, fromVar, toVar) ; OR(_, fromVar, castedVar, toVar)).

ProbablyPartialStorageUpdatePattern(fromVar, toVar, "CONST", baseVal, shiftBytes, shiftBytes + byteLen - 1):-
  BasicVariable_Value(writtenVar, writtenVal),
  byteLen = (strlen(baseVal) - 2 + 1)/2,
  ConstantProbablyShifted(writtenVal, baseVal, shiftBytes),
  (OR(_, writtenVar, fromVar, toVar) ; OR(_, fromVar, writtenVar, toVar)).

ProbablyPartialStorageUpdatePattern(fromVar, toVar, "CONST", writtenVal, 0, byteLen - 1):-
  BasicVariable_Value(writtenVar, writtenVal),
  writtenVal != "0x0", // Zero is handled differently
  !ConstantProbablyShifted(writtenVal, _, _),
  byteLen = (strlen(writtenVal) - 2 + 1)/2,
  (OR(_, writtenVar, fromVar, toVar) ; OR(_, fromVar, writtenVar, toVar)).


ProbablyPartialStorageUpdateSequenceWrite(toVar, kind, writtenVarOrConst, byteLow, byteHigh),
ProbablyPartialStorageUpdateSequenceKeep(toVar, load, storVar, keepByteLow, keepByteHigh):-
  VarHoldsBytesOfStorVar(originVar, load, storVar, 0, 31),
  ByteMaskOpKeepRange(originVar, originMasked, [keepByteLow, keepByteHigh]),
  ProbablyPartialStorageUpdatePattern(originMasked, toVar, kind, writtenVarOrConst, byteLow, byteHigh).

ProbablyPartialStorageUpdateSequenceWrite(toVar, "CONST", "0x0", byteLow, byteHigh),
ProbablyPartialStorageUpdateSequenceKeep(toVar, load, storVar, keepByteLow, keepByteHigh):-
  VarHoldsBytesOfStorVar(originVar, load, storVar, 0, 31),
  ByteMaskOpKeepRange(originVar, originMasked, [keepByteLow, keepByteHigh]),
  ByteMaskOpMaskRange(originVar, originMasked, [byteLow, byteHigh]),
  (OR(_, zeroVar, originMasked, toVar) ; OR(_, originMasked, zeroVar, toVar)),
  BasicVariable_Value(zeroVar, "0x0").

ProbablyPartialStorageUpdateSequenceWrite(toVar, kind, writtenVarOrConst, byteLow, byteHigh):-
  ProbablyPartialStorageUpdateSequenceWrite(originVar, kind, writtenVarOrConst, byteLow, byteHigh),
  ProbablyPartialStorageUpdatePattern(originVar, toVar, _, _, _, _). // TODO: Ensure no conflict

// For completeness, maybe useless, doesn't affect our current test set
ProbablyPartialStorageUpdateSequenceWrite(toVar, kind, writtenVarOrConst, byteLow, byteHigh):-
  ProbablyPartialStorageUpdateSequenceWrite(fromVar, kind, writtenVarOrConst, byteLow, byteHigh),
  (OR(_, zeroVar, fromVar, toVar) ; OR(_, fromVar, zeroVar, toVar)),
  BasicVariable_Value(zeroVar, "0x0").

// For completeness, maybe useless, doesn't affect our current test set
ProbablyPartialStorageUpdateSequenceKeep(toVar, load, storVar, keepByteLow, keepByteHigh):-
  ProbablyPartialStorageUpdateSequenceKeep(fromVar, load, storVar, keepByteLow, keepByteHigh),
  (OR(_, zeroVar, fromVar, toVar) ; OR(_, fromVar, zeroVar, toVar)),
  BasicVariable_Value(zeroVar, "0x0").

ProbablyPartialStorageUpdateSequenceWrite(toVar, kind, writtenVarOrConst, byteLow, byteHigh):-
  ProbablyPartialStorageUpdatePattern(originVar1, toVar, kind, writtenVarOrConst, byteLow, byteHigh),
  ProbablyPartialStorageUpdatePattern(originVar2, toVar, _,  _, _, _),
  originVar1 != originVar2,
  !ProbablyPartialStorageUpdatePattern(_, as(writtenVarOrConst, Variable), _,  _, _, _).

/**
  Could be more complex (allow for parts of the previous writes to survive).
*/
ProbablyPartialStorageUpdateSequenceWrite(toVar, kind, writtenVarOrConst, byteLow, byteHigh):-
  ProbablyPartialStorageUpdateSequenceWrite(originVar, kind, writtenVarOrConst, byteLow, byteHigh),
  ByteMaskOpKeepRange(originVar, toVar, [keepByteLow, keepByteHigh]),
  byteLow >= keepByteLow, keepByteLow < byteHigh, byteHigh <= keepByteHigh.

ProbablyPartialStorageUpdateSequenceWrite(toVar, kind, writtenVarOrConst, byteLow, byteHigh):-
  ProbablyPartialStorageUpdateSequenceWrite(originVar, _, _, _, _),
  ProbablyPartialStorageUpdatePattern(originVar, toVar, kind, writtenVarOrConst, byteLow, byteHigh).

ProbablyPartialStorageUpdateSequenceKeep(toVar, load, storVar, keepByteLow, keepByteHigh):-
  ProbablyPartialStorageUpdateSequenceKeep(originVar, load, storVar, keepByteLow, keepByteHigh),
  ProbablyPartialStorageUpdatePattern(originVar, toVar, _, _, _, _).

// Propagate `ProbablyPartialStorageUpdateSequenceKeep` through masking operations, accounting for difference between ranges 
ProbablyPartialStorageUpdateSequenceKeep(toVar, load, storVar, max(keepByteLow, maskKeepByteLow), min(keepByteHigh, maskKeepByteHigh)):-
  ProbablyPartialStorageUpdateSequenceKeep(originVar, load, storVar, keepByteLow, keepByteHigh),
  ByteMaskOpKeepRange(originVar, toVar, [maskKeepByteLow, maskKeepByteHigh]),
  max(keepByteLow, maskKeepByteLow) <= min(keepByteHigh, maskKeepByteHigh).

UselessSLOAD(sload):-
  ProbablyPartialStorageUpdateSequenceKeep(originVar, sload, _, keepByteLow, keepByteHigh),
  !BytesOfStorVarKept(_, sload, _, _, _),
  ByteMaskOpKeepRange(originVar, _, [maskKeepByteLow, maskKeepByteHigh]),
  max(keepByteLow, maskKeepByteLow) > min(keepByteHigh, maskKeepByteHigh).


VarWrittenToBytesOfStorVar(as(writtenVar, Variable), store, storVar, byteLow, byteHigh):-
  SSTOREToConst(store, storVar, storedVar),
  ProbablyPartialStorageUpdateSequenceWrite(storedVar, "VAR", writtenVar, byteLow, byteHigh).

ConstWrittenToBytesOfStorVar("0xlala", as(writtenConst, Value), store, "lolo", storVar, byteLow, byteHigh):-
  SSTOREToConst(store, storVar, storedVar),
  ProbablyPartialStorageUpdateSequenceWrite(storedVar, "CONST", writtenConst, byteLow, byteHigh).

.decl BytesOfStorVarKept(store: Statement, load: Statement, storVar: symbol, keepByteLow: number, keepByteHigh: number)

BytesOfStorVarKept(store, load, storVar, keepByteLow, keepByteHigh):-
  SSTOREToConst(store, storVar, storedVar),
  ProbablyPartialStorageUpdateSequenceKeep(storedVar, load, storVar, keepByteLow, keepByteHigh).

.decl UselessSLOAD(sload: Statement)
DEBUG_OUTPUT(UselessSLOAD)

.decl ByteOfStorVarKeptOrUpdated(store: Statement, storVar: symbol, byte: number)
DEBUG_OUTPUT(ByteOfStorVarKeptOrUpdated)

ByteOfStorVarKeptOrUpdated(store, storVar, byte):-
  SSTOREToConst(store, storVar, storedVar),
  (
    ProbablyPartialStorageUpdateSequenceKeep(storedVar, _, storVar, byteLow, byteHigh);
    ProbablyPartialStorageUpdateSequenceWrite(storedVar, _, _, byteLow, byteHigh)
  ),
  byte = range(byteLow, byteHigh + 1, 1).

/**
  `byte` is not `ByteOfStorVarKeptOrUpdated()` so the value 0x0 is stored to it.
*/
.decl SSTOREZeroByte(store: Statement, storVar: symbol, byte: number)
DEBUG_OUTPUT(SSTOREZeroByte)

/**
  Bytes from `byteLow` to `byteHigh` are not `ByteOfStorVarKeptOrUpdated()` so the value 0x0 is stored to them.
*/
.decl SSTOREZeroRange(store: Statement, storVar: symbol, byteLow: number, byteHigh: number)
DEBUG_OUTPUT(SSTOREZeroRange)

SSTOREZeroByte(store, storVar, byte):-
  SSTOREToConst(store, storVar, _),
  ByteOfStorVarKeptOrUpdated(store, storVar, _),
  byte = range(0, 32, 1),
  !ByteOfStorVarKeptOrUpdated(store, storVar, byte).

SSTOREZeroRange(store, storVar, byteLow, byteHigh):-
  SSTOREZeroByte(store, storVar, byteLow),
  !SSTOREZeroByte(store, storVar, byteLow - 1),
  SSTOREZeroByte(store, storVar, byteHigh),
  !SSTOREZeroByte(store, storVar, byteHigh + 1),
  byteLow <= byteHigh,
  1 + byteHigh - byteLow = count : {SSTOREZeroByte(store, storVar, k), byteLow <= k, k <= byteHigh}.

ConstWrittenToBytesOfStorVar("0xlala", "0x0", store, "lolo", storVar, byteLow, byteHigh):-
  SSTOREZeroRange(store, storVar, byteLow, byteHigh).


VarWrittenToBytesOfStorVarIsMergedVar(writtenVar, modeledVar, store, storVar, 0, byteHigh):-
  VarWrittenToBytesOfStorVar(writtenVar, store, storVar, 0, byteHigh),
  Statement_Defines(otherLoad, writtenVar, 0),
  VarHoldsBytesOfStorVar(modeledVar, otherLoad, _, 0, byteHigh),
  Statement_Uses(store, storedVar, 1),
  DataFlows(modeledVar, storedVar).

VarWrittenToBytesOfStorVarFinal(modeledVar, store, storVar, byteLow, byteHigh):-
  VarWrittenToBytesOfStorVar(writtenVar, store, storVar, byteLow, byteHigh),
  VarWrittenToBytesOfStorVarIsMergedVar(writtenVar, modeledVar, store, storVar, byteLow, byteHigh).

VarWrittenToBytesOfStorVarFinal(writtenVar, store, storVar, byteLow, byteHigh):-
  VarWrittenToBytesOfStorVar(writtenVar, store, storVar, byteLow, byteHigh),
  !VarWrittenToBytesOfStorVarIsMergedVar(writtenVar, _, store, storVar, byteLow, byteHigh).


BytesOfStorVarKept(store, load, storVar, keepByteLow, keepByteHigh),
ConstWrittenToBytesOfStorVar("0xNoVar", "0x0", store, load, storVar, maskByteLow, maskByteHigh):-
  VarHoldsBytesOfStorVar(originVar, load, storVar, 0, 31),
  ByteMaskOpKeepRange(originVar, storedVar, [keepByteLow, keepByteHigh]),
  ByteMaskOpMaskRange(originVar, storedVar, [maskByteLow, maskByteHigh]),
  SSTOREToConst(store, storVar, storedVar).

/**
  HACK (?) HACK (?) HACK (?)
  If the variable that is being stored on the update of a merged storage var
  is used again, we consider it a fresh "load" of the storage var
  its' shifts and masks populate VarHoldsBytesOfStorVar
  This can happen in optimized code, its good to support it.
**/

VarHoldsBytesOfStorVar(to, store, storVar, bytes, 31):-
  VarWrittenToBytesOfStorVar(_, store, storVar, _, _),
  Statement_Uses(store, storedVar, 1),
  RShiftBytes(storedVar, to, bytes).

VarHoldsBytesOfStorVar(to, store, storVar, 0, maskLen - 1):-
  VarWrittenToBytesOfStorVar(_, store, storVar, _, _),
  Statement_Uses(store, storedVar, 1),
  LowBytesMaskOp(storedVar, to, maskLen).

/**
  Top-Level Global Variables
 */

.decl GlobalVariable(v: Value)

.decl LoadGlobalVariable(stmt: Statement, val: Value, var: Variable)

.decl StoreGlobalVariable(stmt: Statement, val: Value, var: Variable)

.decl StorageVariableInfo(storageVariable: symbol, storageSlot: symbol, byteLow: number, byteHigh: number)


/* Old logic
GlobalVariable(v) :-
  SLOAD(_, index, _),
  Variable_Value(index, v).
*/

GlobalVariable(v):-
  LoadGlobalVariable(_, v, _) ;
  StoreGlobalVariable(_, v, _).


LoadGlobalVariable(stmt, storVar, var):-
  SLOADOfConst(stmt, storVar, var),
  FailedMergedStorageModeling(storVar).

LoadGlobalVariable(stmt, as(storVar, Value), var):-
  SuccessfulMergedStorageModeling(storVar),
  SLOADOfConst(_, storVar, _), // ensure it's a global variable
  VarHoldsBytesOfStorVarFinal(var, _, storVar, 0, 31),
  Statement_Defines(stmt, var, 0).

LoadGlobalVariable(stmt, v, var):-
  SuccessfulMergedStorageModeling(storVar),
  SLOADOfConst(_, storVar, _), // ensure it's a global variable
  VarHoldsBytesOfStorVarFinal(_, _, storVar, low, high),
  VarHoldsBytesOfStorVar(var, _, storVar, low, high),
  Statement_Defines(stmt, var, 0),
  (low != 0 ; high != 31),
  v = MERGED_STORAGE_VAR(storVar, low, high).

StoreGlobalVariable(stmt, storVar, var):-
  SSTOREToConst(stmt, storVar, var),
  FailedMergedStorageModeling(storVar).

StoreGlobalVariable(stmt, storVar, var):-
  SSTOREToConst(stmt, storVar, var),
  SuccessfulMergedStorageModeling(storVar),
  (VarHoldsBytesOfStorVarFinal(_, _, storVar, 0, 31); !SLOADOfConst(_, storVar, _)).

StoreGlobalVariable(store, v, writtenVar):-
  SuccessfulMergedStorageModeling(storVar),
  SSTOREToConst(_, storVar, _), // ensure it's a global variable
  VarWrittenToBytesOfStorVarFinal(writtenVar, store, storVar, byteLow, byteHigh),
  v = MERGED_STORAGE_VAR(storVar, byteLow, byteHigh).

StoreGlobalVariable(store, v, constVar):-
  SuccessfulMergedStorageModeling(storVar),
  SSTOREToConst(_, storVar, _), // ensure it's a global variable
  ConstWrittenToBytesOfStorVar(constVar, _, store, _, storVar, byteLow, byteHigh),
  v = MERGED_STORAGE_VAR(storVar, byteLow, byteHigh).

StorageVariableInfo(MERGED_STORAGE_VAR(storVar, byteLow, byteHigh), storVar, byteLow, byteHigh):-
  SuccessfulMergedStorageModeling(storVar),
  (
    ConstWrittenToBytesOfStorVar(_, _, _, _, storVar, byteLow, byteHigh);
    VarWrittenToBytesOfStorVarFinal(_, _, storVar, byteLow, byteHigh);
    VarHoldsBytesOfStorVarFinal(_, _, storVar, byteLow, byteHigh)
  ),
  byteHigh - byteLow != 31.

StorageVariableInfo(storVar, storVar, 0, 31):-
  SuccessfulMergedStorageModeling(storVar),
  (
    ConstWrittenToBytesOfStorVar(_, _, _, _, storVar, 0, 31);
    VarWrittenToBytesOfStorVarFinal(_, _, storVar, 0, 31);
    VarHoldsBytesOfStorVarFinal(_, _, storVar, 0, 31)
  ).

StorageVariableInfo(storVar, storVar, 0, 31):-
  FailedMergedStorageModeling(storVar).

/**
  Basic type inference
  Hacky for now just to print the correct uintX or address if nessesary.
**/

.decl StorageVariableType(storVar:symbol, type:symbol)

.decl SpecialStorageVariableType(storVar:symbol, type:symbol)

StorageVariableType(storVar, type):-
  StorageVariableInfo(storVar, _, byteLow, byteHigh),
  widthBytes = 1 + byteHigh - byteLow,
  !SpecialStorageVariableType(storVar, _),
  type = cat("uint", to_string(widthBytes * 8)).

StorageVariableType(storVar, type):-
  StorageVariableInfo(storVar, _, _, _),
  SpecialStorageVariableType(storVar, type).

SpecialStorageVariableType(storVar, "address"):-
  StorageVariableInfo(storVar, originStorVar, byteLow, byteHigh),
  VarHoldsBytesOfStorVarFinal(var, _, originStorVar, byteLow, byteHigh),
  widthBytes = 1 + byteHigh - byteLow,
  widthBytes = 20,
  DataFlows(var, addr),
  AddressTypedVar(addr).

SpecialStorageVariableType(storVar, "address"):-
  StorageVariableInfo(storVar, originStorVar, byteLow, byteHigh),
  VarWrittenToBytesOfStorVarFinal(var, _, originStorVar, byteLow, byteHigh),
  widthBytes = 1 + byteHigh - byteLow,
  widthBytes = 20,
  DataFlows(addr, var),
  AddressTypedVar(addr).

// Hack to cover msg.sender == var and other similar things
SpecialStorageVariableType(storVar, "address"):-
  AddressTypedVar(addrFrom),
  DataFlows(addrFrom, addr),
  (EQ(_, otherAddr, addr, _) ; EQ(_, addr, otherAddr, _)),
  DataFlows(var, otherAddr),
  VarHoldsBytesOfStorVarFinal(var, _, originStorVar, byteLow, byteHigh),
  StorageVariableInfo(storVar, originStorVar, byteLow, byteHigh),
  widthBytes = 1 + byteHigh - byteLow,
  widthBytes = 20.

.decl AddressTypedVar(addrVar:Variable)
AddressTypedVar(addr):-
  CALL(_, _, addr, _, _, _, _, _, _);
  STATICCALL(_, _, addr, _, _, _, _, _);
  DELEGATECALL(_, _, addr, _, _, _, _, _);
  SELFDESTRUCT(_, addr);
  EXTCODECOPY(_, addr, _, _, _);
  EXTCODESIZE(_, addr, _);
  EXTCODEHASH(_, addr, _);
  CALLER(_, addr);
  ORIGIN(_, addr);
  ADDRESS(_, addr).

/**
  Temp statements for the source decompiler to hide
**/

DataStructuresTempStmt(load):-
  SuccessfulMergedStorageModeling(storVar),
  VarHoldsBytesOfStorVarFinal(var, load, storVar, _, _),
  Statement_Defines(stmt, var, 0),
  stmt != load.
